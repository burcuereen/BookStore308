{"ast":null,"code":"/**\r\n * lscache library\r\n * Copyright (c) 2011, Pamela Fox\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/* jshint undef:true, browser:true, node:true */\n\n/* global define */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module !== \"undefined\" && module.exports) {\n    // CommonJS/Node module\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.lscache = factory();\n  }\n})(this, function () {\n  // Prefix for all lscache keys\n  var CACHE_PREFIX = 'lscache-'; // Suffix for the key name on the expiration items in localStorage\n\n  var CACHE_SUFFIX = '-cacheexpiration'; // expiration date radix (set to Base-36 for most space savings)\n\n  var EXPIRY_RADIX = 10; // time resolution in milliseconds\n\n  var expiryMilliseconds = 60 * 1000; // ECMAScript max Date (epoch + 1e8 days)\n\n  var maxDate = calculateMaxDate(expiryMilliseconds);\n  var cachedStorage;\n  var cachedJSON;\n  var cacheBucket = '';\n  var warnings = false; // Determines if localStorage is supported in the browser;\n  // result is cached for better performance instead of being run each time.\n  // Feature detection is based on how Modernizr does it;\n  // it's not straightforward due to FF4 issues.\n  // It's not run at parse-time as it takes 200ms in Android.\n\n  function supportsStorage() {\n    var key = '__lscachetest__';\n    var value = key;\n\n    if (cachedStorage !== undefined) {\n      return cachedStorage;\n    } // some browsers will throw an error if you try to access local storage (e.g. brave browser)\n    // hence check is inside a try/catch\n\n\n    try {\n      if (!localStorage) {\n        return false;\n      }\n    } catch (ex) {\n      return false;\n    }\n\n    try {\n      setItem(key, value);\n      removeItem(key);\n      cachedStorage = true;\n    } catch (e) {\n      // If we hit the limit, and we don't have an empty localStorage then it means we have support\n      if (isOutOfSpace(e) && localStorage.length) {\n        cachedStorage = true; // just maxed it out and even the set test failed.\n      } else {\n        cachedStorage = false;\n      }\n    }\n\n    return cachedStorage;\n  } // Check to set if the error is us dealing with being out of space\n\n\n  function isOutOfSpace(e) {\n    return e && (e.name === 'QUOTA_EXCEEDED_ERR' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED' || e.name === 'QuotaExceededError');\n  } // Determines if native JSON (de-)serialization is supported in the browser.\n\n\n  function supportsJSON() {\n    /*jshint eqnull:true */\n    if (cachedJSON === undefined) {\n      cachedJSON = window.JSON != null;\n    }\n\n    return cachedJSON;\n  }\n  /**\r\n   * Returns a string where all RegExp special characters are escaped with a \\.\r\n   * @param {String} text\r\n   * @return {string}\r\n   */\n\n\n  function escapeRegExpSpecialCharacters(text) {\n    return text.replace(/[[\\]{}()*+?.\\\\^$|]/g, '\\\\$&');\n  }\n  /**\r\n   * Returns the full string for the localStorage expiration item.\r\n   * @param {String} key\r\n   * @return {string}\r\n   */\n\n\n  function expirationKey(key) {\n    return key + CACHE_SUFFIX;\n  }\n  /**\r\n   * Returns the number of minutes since the epoch.\r\n   * @return {number}\r\n   */\n\n\n  function currentTime() {\n    return Math.floor(new Date().getTime() / expiryMilliseconds);\n  }\n  /**\r\n   * Wrapper functions for localStorage methods\r\n   */\n\n\n  function getItem(key) {\n    return localStorage.getItem(CACHE_PREFIX + cacheBucket + key);\n  }\n\n  function setItem(key, value) {\n    // Fix for iPad issue - sometimes throws QUOTA_EXCEEDED_ERR on setItem.\n    localStorage.removeItem(CACHE_PREFIX + cacheBucket + key);\n    localStorage.setItem(CACHE_PREFIX + cacheBucket + key, value);\n  }\n\n  function removeItem(key) {\n    localStorage.removeItem(CACHE_PREFIX + cacheBucket + key);\n  }\n\n  function eachKey(fn) {\n    var prefixRegExp = new RegExp('^' + CACHE_PREFIX + escapeRegExpSpecialCharacters(cacheBucket) + '(.*)'); // Loop in reverse as removing items will change indices of tail\n\n    for (var i = localStorage.length - 1; i >= 0; --i) {\n      var key = localStorage.key(i);\n      key = key && key.match(prefixRegExp);\n      key = key && key[1];\n\n      if (key && key.indexOf(CACHE_SUFFIX) < 0) {\n        fn(key, expirationKey(key));\n      }\n    }\n  }\n\n  function flushItem(key) {\n    var exprKey = expirationKey(key);\n    removeItem(key);\n    removeItem(exprKey);\n  }\n\n  function flushExpiredItem(key) {\n    var exprKey = expirationKey(key);\n    var expr = getItem(exprKey);\n\n    if (expr) {\n      var expirationTime = parseInt(expr, EXPIRY_RADIX); // Check if we should actually kick item out of storage\n\n      if (currentTime() >= expirationTime) {\n        removeItem(key);\n        removeItem(exprKey);\n        return true;\n      }\n    }\n  }\n\n  function warn(message, err) {\n    if (!warnings) return;\n    if (!('console' in window) || typeof window.console.warn !== 'function') return;\n    window.console.warn(\"lscache - \" + message);\n    if (err) window.console.warn(\"lscache - The error was: \" + err.message);\n  }\n\n  function calculateMaxDate(expiryMilliseconds) {\n    return Math.floor(8.64e15 / expiryMilliseconds);\n  }\n\n  var lscache = {\n    /**\r\n     * Stores the value in localStorage. Expires after specified number of minutes.\r\n     * @param {string} key\r\n     * @param {Object|string} value\r\n     * @param {number} time\r\n     * @return true if the value was inserted successfully\r\n     */\n    set: function (key, value, time) {\n      if (!supportsStorage()) return false; // If we don't get a string value, try to stringify\n      // In future, localStorage may properly support storing non-strings\n      // and this can be removed.\n\n      if (!supportsJSON()) return false;\n\n      try {\n        value = JSON.stringify(value);\n      } catch (e) {\n        // Sometimes we can't stringify due to circular refs\n        // in complex objects, so we won't bother storing then.\n        return false;\n      }\n\n      try {\n        setItem(key, value);\n      } catch (e) {\n        if (isOutOfSpace(e)) {\n          // If we exceeded the quota, then we will sort\n          // by the expire time, and then remove the N oldest\n          var storedKeys = [];\n          var storedKey;\n          eachKey(function (key, exprKey) {\n            var expiration = getItem(exprKey);\n\n            if (expiration) {\n              expiration = parseInt(expiration, EXPIRY_RADIX);\n            } else {\n              // TODO: Store date added for non-expiring items for smarter removal\n              expiration = maxDate;\n            }\n\n            storedKeys.push({\n              key: key,\n              size: (getItem(key) || '').length,\n              expiration: expiration\n            });\n          }); // Sorts the keys with oldest expiration time last\n\n          storedKeys.sort(function (a, b) {\n            return b.expiration - a.expiration;\n          });\n          var targetSize = (value || '').length;\n\n          while (storedKeys.length && targetSize > 0) {\n            storedKey = storedKeys.pop();\n            warn(\"Cache is full, removing item with key '\" + key + \"'\");\n            flushItem(storedKey.key);\n            targetSize -= storedKey.size;\n          }\n\n          try {\n            setItem(key, value);\n          } catch (e) {\n            // value may be larger than total quota\n            warn(\"Could not add item with key '\" + key + \"', perhaps it's too big?\", e);\n            return false;\n          }\n        } else {\n          // If it was some other error, just give up.\n          warn(\"Could not add item with key '\" + key + \"'\", e);\n          return false;\n        }\n      } // If a time is specified, store expiration info in localStorage\n\n\n      if (time) {\n        setItem(expirationKey(key), (currentTime() + time).toString(EXPIRY_RADIX));\n      } else {\n        // In case they previously set a time, remove that info from localStorage.\n        removeItem(expirationKey(key));\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Retrieves specified value from localStorage, if not expired.\r\n     * @param {string} key\r\n     * @return {string|Object}\r\n     */\n    get: function (key) {\n      if (!supportsStorage()) return null; // Return the de-serialized item if not expired\n\n      if (flushExpiredItem(key)) {\n        return null;\n      } // Tries to de-serialize stored value if its an object, and returns the normal value otherwise.\n\n\n      var value = getItem(key);\n\n      if (!value || !supportsJSON()) {\n        return value;\n      }\n\n      try {\n        // We can't tell if its JSON or a string, so we try to parse\n        return JSON.parse(value);\n      } catch (e) {\n        // If we can't parse, it's probably because it isn't an object\n        return value;\n      }\n    },\n\n    /**\r\n     * Removes a value from localStorage.\r\n     * Equivalent to 'delete' in memcache, but that's a keyword in JS.\r\n     * @param {string} key\r\n     */\n    remove: function (key) {\n      if (!supportsStorage()) return;\n      flushItem(key);\n    },\n\n    /**\r\n     * Returns whether local storage is supported.\r\n     * Currently exposed for testing purposes.\r\n     * @return {boolean}\r\n     */\n    supported: function () {\n      return supportsStorage();\n    },\n\n    /**\r\n     * Flushes all lscache items and expiry markers without affecting rest of localStorage\r\n     */\n    flush: function () {\n      if (!supportsStorage()) return;\n      eachKey(function (key) {\n        flushItem(key);\n      });\n    },\n\n    /**\r\n     * Flushes expired lscache items and expiry markers without affecting rest of localStorage\r\n     */\n    flushExpired: function () {\n      if (!supportsStorage()) return;\n      eachKey(function (key) {\n        flushExpiredItem(key);\n      });\n    },\n\n    /**\r\n     * Appends CACHE_PREFIX so lscache will partition data in to different buckets.\r\n     * @param {string} bucket\r\n     */\n    setBucket: function (bucket) {\n      cacheBucket = bucket;\n    },\n\n    /**\r\n     * Resets the string being appended to CACHE_PREFIX so lscache will use the default storage behavior.\r\n     */\n    resetBucket: function () {\n      cacheBucket = '';\n    },\n\n    /**\r\n     * @returns {number} The currently set number of milliseconds each time unit represents in\r\n     *   the set() function's \"time\" argument.\r\n     */\n    getExpiryMilliseconds: function () {\n      return expiryMilliseconds;\n    },\n\n    /**\r\n     * Sets the number of milliseconds each time unit represents in the set() function's\r\n     *   \"time\" argument.\r\n     * Sample values:\r\n     *  1: each time unit = 1 millisecond\r\n     *  1000: each time unit = 1 second\r\n     *  60000: each time unit = 1 minute (Default value)\r\n     *  360000: each time unit = 1 hour\r\n     * @param {number} milliseconds\r\n     */\n    setExpiryMilliseconds: function (milliseconds) {\n      expiryMilliseconds = milliseconds;\n      maxDate = calculateMaxDate(expiryMilliseconds);\n    },\n\n    /**\r\n     * Sets whether to display warnings when an item is removed from the cache or not.\r\n     */\n    enableWarnings: function (enabled) {\n      warnings = enabled;\n    }\n  }; // Return the module\n\n  return lscache;\n});","map":{"version":3,"sources":["/Users/burcueren/BSS1/node_modules/lscache/lscache.js"],"names":["root","factory","define","amd","module","exports","lscache","CACHE_PREFIX","CACHE_SUFFIX","EXPIRY_RADIX","expiryMilliseconds","maxDate","calculateMaxDate","cachedStorage","cachedJSON","cacheBucket","warnings","supportsStorage","key","value","undefined","localStorage","ex","setItem","removeItem","e","isOutOfSpace","length","name","supportsJSON","window","JSON","escapeRegExpSpecialCharacters","text","replace","expirationKey","currentTime","Math","floor","Date","getTime","getItem","eachKey","fn","prefixRegExp","RegExp","i","match","indexOf","flushItem","exprKey","flushExpiredItem","expr","expirationTime","parseInt","warn","message","err","console","set","time","stringify","storedKeys","storedKey","expiration","push","size","sort","a","b","targetSize","pop","toString","get","parse","remove","supported","flush","flushExpired","setBucket","bucket","resetBucket","getExpiryMilliseconds","setExpiryMilliseconds","milliseconds","enableWarnings","enabled"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AAEC,WAAUA,IAAV,EAAgBC,OAAhB,EAAyB;AACtB,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgD;AAC5C;AACAD,IAAAA,MAAM,CAAC,EAAD,EAAKD,OAAL,CAAN;AACH,GAHD,MAGO,IAAI,OAAOG,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,OAA5C,EAAqD;AACxD;AACAD,IAAAA,MAAM,CAACC,OAAP,GAAiBJ,OAAO,EAAxB;AACH,GAHM,MAGA;AACH;AACAD,IAAAA,IAAI,CAACM,OAAL,GAAeL,OAAO,EAAtB;AACH;AACJ,CAXA,EAWC,IAXD,EAWO,YAAY;AAElB;AACA,MAAIM,YAAY,GAAG,UAAnB,CAHkB,CAKlB;;AACA,MAAIC,YAAY,GAAG,kBAAnB,CANkB,CAQlB;;AACA,MAAIC,YAAY,GAAG,EAAnB,CATkB,CAWlB;;AACA,MAAIC,kBAAkB,GAAG,KAAK,IAA9B,CAZkB,CAalB;;AACA,MAAIC,OAAO,GAAGC,gBAAgB,CAACF,kBAAD,CAA9B;AAEA,MAAIG,aAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,QAAQ,GAAG,KAAf,CAnBkB,CAqBlB;AACA;AACA;AACA;AACA;;AACA,WAASC,eAAT,GAA2B;AACzB,QAAIC,GAAG,GAAG,iBAAV;AACA,QAAIC,KAAK,GAAGD,GAAZ;;AAEA,QAAIL,aAAa,KAAKO,SAAtB,EAAiC;AAC/B,aAAOP,aAAP;AACD,KANwB,CAQzB;AACA;;;AACA,QAAI;AACF,UAAI,CAACQ,YAAL,EAAmB;AACjB,eAAO,KAAP;AACD;AACF,KAJD,CAIE,OAAOC,EAAP,EAAW;AACX,aAAO,KAAP;AACD;;AAED,QAAI;AACFC,MAAAA,OAAO,CAACL,GAAD,EAAMC,KAAN,CAAP;AACAK,MAAAA,UAAU,CAACN,GAAD,CAAV;AACAL,MAAAA,aAAa,GAAG,IAAhB;AACD,KAJD,CAIE,OAAOY,CAAP,EAAU;AACR;AACA,UAAIC,YAAY,CAACD,CAAD,CAAZ,IAAmBJ,YAAY,CAACM,MAApC,EAA4C;AACxCd,QAAAA,aAAa,GAAG,IAAhB,CADwC,CAClB;AACzB,OAFD,MAEO;AACHA,QAAAA,aAAa,GAAG,KAAhB;AACH;AACJ;;AACD,WAAOA,aAAP;AACD,GAzDiB,CA2DlB;;;AACA,WAASa,YAAT,CAAsBD,CAAtB,EAAyB;AACvB,WAAOA,CAAC,KACNA,CAAC,CAACG,IAAF,KAAW,oBAAX,IACAH,CAAC,CAACG,IAAF,KAAW,4BADX,IAEAH,CAAC,CAACG,IAAF,KAAW,oBAHL,CAAR;AAKD,GAlEiB,CAoElB;;;AACA,WAASC,YAAT,GAAwB;AACtB;AACA,QAAIf,UAAU,KAAKM,SAAnB,EAA8B;AAC5BN,MAAAA,UAAU,GAAIgB,MAAM,CAACC,IAAP,IAAe,IAA7B;AACD;;AACD,WAAOjB,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASkB,6BAAT,CAAuCC,IAAvC,EAA6C;AAC3C,WAAOA,IAAI,CAACC,OAAL,CAAa,qBAAb,EAAoC,MAApC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASC,aAAT,CAAuBjB,GAAvB,EAA4B;AAC1B,WAAOA,GAAG,GAAGV,YAAb;AACD;AAED;AACF;AACA;AACA;;;AACE,WAAS4B,WAAT,GAAuB;AACrB,WAAOC,IAAI,CAACC,KAAL,CAAY,IAAIC,IAAJ,GAAWC,OAAX,EAAD,GAAuB9B,kBAAlC,CAAP;AACD;AAED;AACF;AACA;;;AAEE,WAAS+B,OAAT,CAAiBvB,GAAjB,EAAsB;AACpB,WAAOG,YAAY,CAACoB,OAAb,CAAqBlC,YAAY,GAAGQ,WAAf,GAA6BG,GAAlD,CAAP;AACD;;AAED,WAASK,OAAT,CAAiBL,GAAjB,EAAsBC,KAAtB,EAA6B;AAC3B;AACAE,IAAAA,YAAY,CAACG,UAAb,CAAwBjB,YAAY,GAAGQ,WAAf,GAA6BG,GAArD;AACAG,IAAAA,YAAY,CAACE,OAAb,CAAqBhB,YAAY,GAAGQ,WAAf,GAA6BG,GAAlD,EAAuDC,KAAvD;AACD;;AAED,WAASK,UAAT,CAAoBN,GAApB,EAAyB;AACvBG,IAAAA,YAAY,CAACG,UAAb,CAAwBjB,YAAY,GAAGQ,WAAf,GAA6BG,GAArD;AACD;;AAED,WAASwB,OAAT,CAAiBC,EAAjB,EAAqB;AACnB,QAAIC,YAAY,GAAG,IAAIC,MAAJ,CAAW,MAAMtC,YAAN,GAAqByB,6BAA6B,CAACjB,WAAD,CAAlD,GAAkE,MAA7E,CAAnB,CADmB,CAEnB;;AACA,SAAK,IAAI+B,CAAC,GAAGzB,YAAY,CAACM,MAAb,GAAoB,CAAjC,EAAoCmB,CAAC,IAAI,CAAzC,EAA6C,EAAEA,CAA/C,EAAkD;AAChD,UAAI5B,GAAG,GAAGG,YAAY,CAACH,GAAb,CAAiB4B,CAAjB,CAAV;AACA5B,MAAAA,GAAG,GAAGA,GAAG,IAAIA,GAAG,CAAC6B,KAAJ,CAAUH,YAAV,CAAb;AACA1B,MAAAA,GAAG,GAAGA,GAAG,IAAIA,GAAG,CAAC,CAAD,CAAhB;;AACA,UAAIA,GAAG,IAAIA,GAAG,CAAC8B,OAAJ,CAAYxC,YAAZ,IAA4B,CAAvC,EAA0C;AACxCmC,QAAAA,EAAE,CAACzB,GAAD,EAAMiB,aAAa,CAACjB,GAAD,CAAnB,CAAF;AACD;AACF;AACF;;AAED,WAAS+B,SAAT,CAAmB/B,GAAnB,EAAwB;AACtB,QAAIgC,OAAO,GAAGf,aAAa,CAACjB,GAAD,CAA3B;AAEAM,IAAAA,UAAU,CAACN,GAAD,CAAV;AACAM,IAAAA,UAAU,CAAC0B,OAAD,CAAV;AACD;;AAED,WAASC,gBAAT,CAA0BjC,GAA1B,EAA+B;AAC7B,QAAIgC,OAAO,GAAGf,aAAa,CAACjB,GAAD,CAA3B;AACA,QAAIkC,IAAI,GAAGX,OAAO,CAACS,OAAD,CAAlB;;AAEA,QAAIE,IAAJ,EAAU;AACR,UAAIC,cAAc,GAAGC,QAAQ,CAACF,IAAD,EAAO3C,YAAP,CAA7B,CADQ,CAGR;;AACA,UAAI2B,WAAW,MAAMiB,cAArB,EAAqC;AACnC7B,QAAAA,UAAU,CAACN,GAAD,CAAV;AACAM,QAAAA,UAAU,CAAC0B,OAAD,CAAV;AACA,eAAO,IAAP;AACD;AACF;AACF;;AAED,WAASK,IAAT,CAAcC,OAAd,EAAuBC,GAAvB,EAA4B;AAC1B,QAAI,CAACzC,QAAL,EAAe;AACf,QAAI,EAAE,aAAac,MAAf,KAA0B,OAAOA,MAAM,CAAC4B,OAAP,CAAeH,IAAtB,KAA+B,UAA7D,EAAyE;AACzEzB,IAAAA,MAAM,CAAC4B,OAAP,CAAeH,IAAf,CAAoB,eAAeC,OAAnC;AACA,QAAIC,GAAJ,EAAS3B,MAAM,CAAC4B,OAAP,CAAeH,IAAf,CAAoB,8BAA8BE,GAAG,CAACD,OAAtD;AACV;;AAED,WAAS5C,gBAAT,CAA0BF,kBAA1B,EAA8C;AAC5C,WAAO2B,IAAI,CAACC,KAAL,CAAW,UAAQ5B,kBAAnB,CAAP;AACD;;AAED,MAAIJ,OAAO,GAAG;AACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACIqD,IAAAA,GAAG,EAAE,UAASzC,GAAT,EAAcC,KAAd,EAAqByC,IAArB,EAA2B;AAC9B,UAAI,CAAC3C,eAAe,EAApB,EAAwB,OAAO,KAAP,CADM,CAG9B;AACA;AACA;;AAEA,UAAI,CAACY,YAAY,EAAjB,EAAqB,OAAO,KAAP;;AACrB,UAAI;AACFV,QAAAA,KAAK,GAAGY,IAAI,CAAC8B,SAAL,CAAe1C,KAAf,CAAR;AACD,OAFD,CAEE,OAAOM,CAAP,EAAU;AACV;AACA;AACA,eAAO,KAAP;AACD;;AAED,UAAI;AACFF,QAAAA,OAAO,CAACL,GAAD,EAAMC,KAAN,CAAP;AACD,OAFD,CAEE,OAAOM,CAAP,EAAU;AACV,YAAIC,YAAY,CAACD,CAAD,CAAhB,EAAqB;AACnB;AACA;AACA,cAAIqC,UAAU,GAAG,EAAjB;AACA,cAAIC,SAAJ;AACArB,UAAAA,OAAO,CAAC,UAASxB,GAAT,EAAcgC,OAAd,EAAuB;AAC7B,gBAAIc,UAAU,GAAGvB,OAAO,CAACS,OAAD,CAAxB;;AACA,gBAAIc,UAAJ,EAAgB;AACdA,cAAAA,UAAU,GAAGV,QAAQ,CAACU,UAAD,EAAavD,YAAb,CAArB;AACD,aAFD,MAEO;AACL;AACAuD,cAAAA,UAAU,GAAGrD,OAAb;AACD;;AACDmD,YAAAA,UAAU,CAACG,IAAX,CAAgB;AACd/C,cAAAA,GAAG,EAAEA,GADS;AAEdgD,cAAAA,IAAI,EAAE,CAACzB,OAAO,CAACvB,GAAD,CAAP,IAAgB,EAAjB,EAAqBS,MAFb;AAGdqC,cAAAA,UAAU,EAAEA;AAHE,aAAhB;AAKD,WAbM,CAAP,CALmB,CAmBnB;;AACAF,UAAAA,UAAU,CAACK,IAAX,CAAgB,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAAE,mBAAQA,CAAC,CAACL,UAAF,GAAaI,CAAC,CAACJ,UAAvB;AAAqC,WAAtE;AAEA,cAAIM,UAAU,GAAG,CAACnD,KAAK,IAAE,EAAR,EAAYQ,MAA7B;;AACA,iBAAOmC,UAAU,CAACnC,MAAX,IAAqB2C,UAAU,GAAG,CAAzC,EAA4C;AAC1CP,YAAAA,SAAS,GAAGD,UAAU,CAACS,GAAX,EAAZ;AACAhB,YAAAA,IAAI,CAAC,4CAA4CrC,GAA5C,GAAkD,GAAnD,CAAJ;AACA+B,YAAAA,SAAS,CAACc,SAAS,CAAC7C,GAAX,CAAT;AACAoD,YAAAA,UAAU,IAAIP,SAAS,CAACG,IAAxB;AACD;;AACD,cAAI;AACF3C,YAAAA,OAAO,CAACL,GAAD,EAAMC,KAAN,CAAP;AACD,WAFD,CAEE,OAAOM,CAAP,EAAU;AACV;AACA8B,YAAAA,IAAI,CAAC,kCAAkCrC,GAAlC,GAAwC,0BAAzC,EAAqEO,CAArE,CAAJ;AACA,mBAAO,KAAP;AACD;AACF,SApCD,MAoCO;AACL;AACA8B,UAAAA,IAAI,CAAC,kCAAkCrC,GAAlC,GAAwC,GAAzC,EAA8CO,CAA9C,CAAJ;AACA,iBAAO,KAAP;AACD;AACF,OA5D6B,CA8D9B;;;AACA,UAAImC,IAAJ,EAAU;AACRrC,QAAAA,OAAO,CAACY,aAAa,CAACjB,GAAD,CAAd,EAAqB,CAACkB,WAAW,KAAKwB,IAAjB,EAAuBY,QAAvB,CAAgC/D,YAAhC,CAArB,CAAP;AACD,OAFD,MAEO;AACL;AACAe,QAAAA,UAAU,CAACW,aAAa,CAACjB,GAAD,CAAd,CAAV;AACD;;AACD,aAAO,IAAP;AACD,KA9EW;;AAgFZ;AACJ;AACA;AACA;AACA;AACIuD,IAAAA,GAAG,EAAE,UAASvD,GAAT,EAAc;AACjB,UAAI,CAACD,eAAe,EAApB,EAAwB,OAAO,IAAP,CADP,CAGjB;;AACA,UAAIkC,gBAAgB,CAACjC,GAAD,CAApB,EAA2B;AAAE,eAAO,IAAP;AAAc,OAJ1B,CAMjB;;;AACA,UAAIC,KAAK,GAAGsB,OAAO,CAACvB,GAAD,CAAnB;;AACA,UAAI,CAACC,KAAD,IAAU,CAACU,YAAY,EAA3B,EAA+B;AAC7B,eAAOV,KAAP;AACD;;AAED,UAAI;AACF;AACA,eAAOY,IAAI,CAAC2C,KAAL,CAAWvD,KAAX,CAAP;AACD,OAHD,CAGE,OAAOM,CAAP,EAAU;AACV;AACA,eAAON,KAAP;AACD;AACF,KAxGW;;AA0GZ;AACJ;AACA;AACA;AACA;AACIwD,IAAAA,MAAM,EAAE,UAASzD,GAAT,EAAc;AACpB,UAAI,CAACD,eAAe,EAApB,EAAwB;AAExBgC,MAAAA,SAAS,CAAC/B,GAAD,CAAT;AACD,KAnHW;;AAqHZ;AACJ;AACA;AACA;AACA;AACI0D,IAAAA,SAAS,EAAE,YAAW;AACpB,aAAO3D,eAAe,EAAtB;AACD,KA5HW;;AA8HZ;AACJ;AACA;AACI4D,IAAAA,KAAK,EAAE,YAAW;AAChB,UAAI,CAAC5D,eAAe,EAApB,EAAwB;AAExByB,MAAAA,OAAO,CAAC,UAASxB,GAAT,EAAc;AACpB+B,QAAAA,SAAS,CAAC/B,GAAD,CAAT;AACD,OAFM,CAAP;AAGD,KAvIW;;AAyIZ;AACJ;AACA;AACI4D,IAAAA,YAAY,EAAE,YAAW;AACvB,UAAI,CAAC7D,eAAe,EAApB,EAAwB;AAExByB,MAAAA,OAAO,CAAC,UAASxB,GAAT,EAAc;AACpBiC,QAAAA,gBAAgB,CAACjC,GAAD,CAAhB;AACD,OAFM,CAAP;AAGD,KAlJW;;AAoJZ;AACJ;AACA;AACA;AACI6D,IAAAA,SAAS,EAAE,UAASC,MAAT,EAAiB;AAC1BjE,MAAAA,WAAW,GAAGiE,MAAd;AACD,KA1JW;;AA4JZ;AACJ;AACA;AACIC,IAAAA,WAAW,EAAE,YAAW;AACtBlE,MAAAA,WAAW,GAAG,EAAd;AACD,KAjKW;;AAmKZ;AACJ;AACA;AACA;AACImE,IAAAA,qBAAqB,EAAE,YAAW;AAChC,aAAOxE,kBAAP;AACD,KAzKW;;AA2KZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIyE,IAAAA,qBAAqB,EAAE,UAASC,YAAT,EAAuB;AAC1C1E,MAAAA,kBAAkB,GAAG0E,YAArB;AACAzE,MAAAA,OAAO,GAAGC,gBAAgB,CAACF,kBAAD,CAA1B;AACH,KAxLW;;AA0LZ;AACJ;AACA;AACI2E,IAAAA,cAAc,EAAE,UAASC,OAAT,EAAkB;AAChCtE,MAAAA,QAAQ,GAAGsE,OAAX;AACD;AA/LW,GAAd,CAxKkB,CA0WlB;;AACA,SAAOhF,OAAP;AACD,CAvXA,CAAD","sourcesContent":["/**\r\n * lscache library\r\n * Copyright (c) 2011, Pamela Fox\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* jshint undef:true, browser:true, node:true */\r\n/* global define */\r\n\r\n(function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n        define([], factory);\r\n    } else if (typeof module !== \"undefined\" && module.exports) {\r\n        // CommonJS/Node module\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals\r\n        root.lscache = factory();\r\n    }\r\n}(this, function () {\r\n\r\n  // Prefix for all lscache keys\r\n  var CACHE_PREFIX = 'lscache-';\r\n\r\n  // Suffix for the key name on the expiration items in localStorage\r\n  var CACHE_SUFFIX = '-cacheexpiration';\r\n\r\n  // expiration date radix (set to Base-36 for most space savings)\r\n  var EXPIRY_RADIX = 10;\r\n\r\n  // time resolution in milliseconds\r\n  var expiryMilliseconds = 60 * 1000;\r\n  // ECMAScript max Date (epoch + 1e8 days)\r\n  var maxDate = calculateMaxDate(expiryMilliseconds);\r\n\r\n  var cachedStorage;\r\n  var cachedJSON;\r\n  var cacheBucket = '';\r\n  var warnings = false;\r\n\r\n  // Determines if localStorage is supported in the browser;\r\n  // result is cached for better performance instead of being run each time.\r\n  // Feature detection is based on how Modernizr does it;\r\n  // it's not straightforward due to FF4 issues.\r\n  // It's not run at parse-time as it takes 200ms in Android.\r\n  function supportsStorage() {\r\n    var key = '__lscachetest__';\r\n    var value = key;\r\n\r\n    if (cachedStorage !== undefined) {\r\n      return cachedStorage;\r\n    }\r\n\r\n    // some browsers will throw an error if you try to access local storage (e.g. brave browser)\r\n    // hence check is inside a try/catch\r\n    try {\r\n      if (!localStorage) {\r\n        return false;\r\n      }\r\n    } catch (ex) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      setItem(key, value);\r\n      removeItem(key);\r\n      cachedStorage = true;\r\n    } catch (e) {\r\n        // If we hit the limit, and we don't have an empty localStorage then it means we have support\r\n        if (isOutOfSpace(e) && localStorage.length) {\r\n            cachedStorage = true; // just maxed it out and even the set test failed.\r\n        } else {\r\n            cachedStorage = false;\r\n        }\r\n    }\r\n    return cachedStorage;\r\n  }\r\n\r\n  // Check to set if the error is us dealing with being out of space\r\n  function isOutOfSpace(e) {\r\n    return e && (\r\n      e.name === 'QUOTA_EXCEEDED_ERR' ||\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||\r\n      e.name === 'QuotaExceededError'\r\n    );\r\n  }\r\n\r\n  // Determines if native JSON (de-)serialization is supported in the browser.\r\n  function supportsJSON() {\r\n    /*jshint eqnull:true */\r\n    if (cachedJSON === undefined) {\r\n      cachedJSON = (window.JSON != null);\r\n    }\r\n    return cachedJSON;\r\n  }\r\n\r\n  /**\r\n   * Returns a string where all RegExp special characters are escaped with a \\.\r\n   * @param {String} text\r\n   * @return {string}\r\n   */\r\n  function escapeRegExpSpecialCharacters(text) {\r\n    return text.replace(/[[\\]{}()*+?.\\\\^$|]/g, '\\\\$&');\r\n  }\r\n\r\n  /**\r\n   * Returns the full string for the localStorage expiration item.\r\n   * @param {String} key\r\n   * @return {string}\r\n   */\r\n  function expirationKey(key) {\r\n    return key + CACHE_SUFFIX;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of minutes since the epoch.\r\n   * @return {number}\r\n   */\r\n  function currentTime() {\r\n    return Math.floor((new Date().getTime())/expiryMilliseconds);\r\n  }\r\n\r\n  /**\r\n   * Wrapper functions for localStorage methods\r\n   */\r\n\r\n  function getItem(key) {\r\n    return localStorage.getItem(CACHE_PREFIX + cacheBucket + key);\r\n  }\r\n\r\n  function setItem(key, value) {\r\n    // Fix for iPad issue - sometimes throws QUOTA_EXCEEDED_ERR on setItem.\r\n    localStorage.removeItem(CACHE_PREFIX + cacheBucket + key);\r\n    localStorage.setItem(CACHE_PREFIX + cacheBucket + key, value);\r\n  }\r\n\r\n  function removeItem(key) {\r\n    localStorage.removeItem(CACHE_PREFIX + cacheBucket + key);\r\n  }\r\n\r\n  function eachKey(fn) {\r\n    var prefixRegExp = new RegExp('^' + CACHE_PREFIX + escapeRegExpSpecialCharacters(cacheBucket) + '(.*)');\r\n    // Loop in reverse as removing items will change indices of tail\r\n    for (var i = localStorage.length-1; i >= 0 ; --i) {\r\n      var key = localStorage.key(i);\r\n      key = key && key.match(prefixRegExp);\r\n      key = key && key[1];\r\n      if (key && key.indexOf(CACHE_SUFFIX) < 0) {\r\n        fn(key, expirationKey(key));\r\n      }\r\n    }\r\n  }\r\n\r\n  function flushItem(key) {\r\n    var exprKey = expirationKey(key);\r\n\r\n    removeItem(key);\r\n    removeItem(exprKey);\r\n  }\r\n\r\n  function flushExpiredItem(key) {\r\n    var exprKey = expirationKey(key);\r\n    var expr = getItem(exprKey);\r\n\r\n    if (expr) {\r\n      var expirationTime = parseInt(expr, EXPIRY_RADIX);\r\n\r\n      // Check if we should actually kick item out of storage\r\n      if (currentTime() >= expirationTime) {\r\n        removeItem(key);\r\n        removeItem(exprKey);\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  function warn(message, err) {\r\n    if (!warnings) return;\r\n    if (!('console' in window) || typeof window.console.warn !== 'function') return;\r\n    window.console.warn(\"lscache - \" + message);\r\n    if (err) window.console.warn(\"lscache - The error was: \" + err.message);\r\n  }\r\n\r\n  function calculateMaxDate(expiryMilliseconds) {\r\n    return Math.floor(8.64e15/expiryMilliseconds);\r\n  }\r\n\r\n  var lscache = {\r\n    /**\r\n     * Stores the value in localStorage. Expires after specified number of minutes.\r\n     * @param {string} key\r\n     * @param {Object|string} value\r\n     * @param {number} time\r\n     * @return true if the value was inserted successfully\r\n     */\r\n    set: function(key, value, time) {\r\n      if (!supportsStorage()) return false;\r\n\r\n      // If we don't get a string value, try to stringify\r\n      // In future, localStorage may properly support storing non-strings\r\n      // and this can be removed.\r\n\r\n      if (!supportsJSON()) return false;\r\n      try {\r\n        value = JSON.stringify(value);\r\n      } catch (e) {\r\n        // Sometimes we can't stringify due to circular refs\r\n        // in complex objects, so we won't bother storing then.\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        setItem(key, value);\r\n      } catch (e) {\r\n        if (isOutOfSpace(e)) {\r\n          // If we exceeded the quota, then we will sort\r\n          // by the expire time, and then remove the N oldest\r\n          var storedKeys = [];\r\n          var storedKey;\r\n          eachKey(function(key, exprKey) {\r\n            var expiration = getItem(exprKey);\r\n            if (expiration) {\r\n              expiration = parseInt(expiration, EXPIRY_RADIX);\r\n            } else {\r\n              // TODO: Store date added for non-expiring items for smarter removal\r\n              expiration = maxDate;\r\n            }\r\n            storedKeys.push({\r\n              key: key,\r\n              size: (getItem(key) || '').length,\r\n              expiration: expiration\r\n            });\r\n          });\r\n          // Sorts the keys with oldest expiration time last\r\n          storedKeys.sort(function(a, b) { return (b.expiration-a.expiration); });\r\n\r\n          var targetSize = (value||'').length;\r\n          while (storedKeys.length && targetSize > 0) {\r\n            storedKey = storedKeys.pop();\r\n            warn(\"Cache is full, removing item with key '\" + key + \"'\");\r\n            flushItem(storedKey.key);\r\n            targetSize -= storedKey.size;\r\n          }\r\n          try {\r\n            setItem(key, value);\r\n          } catch (e) {\r\n            // value may be larger than total quota\r\n            warn(\"Could not add item with key '\" + key + \"', perhaps it's too big?\", e);\r\n            return false;\r\n          }\r\n        } else {\r\n          // If it was some other error, just give up.\r\n          warn(\"Could not add item with key '\" + key + \"'\", e);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // If a time is specified, store expiration info in localStorage\r\n      if (time) {\r\n        setItem(expirationKey(key), (currentTime() + time).toString(EXPIRY_RADIX));\r\n      } else {\r\n        // In case they previously set a time, remove that info from localStorage.\r\n        removeItem(expirationKey(key));\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Retrieves specified value from localStorage, if not expired.\r\n     * @param {string} key\r\n     * @return {string|Object}\r\n     */\r\n    get: function(key) {\r\n      if (!supportsStorage()) return null;\r\n\r\n      // Return the de-serialized item if not expired\r\n      if (flushExpiredItem(key)) { return null; }\r\n\r\n      // Tries to de-serialize stored value if its an object, and returns the normal value otherwise.\r\n      var value = getItem(key);\r\n      if (!value || !supportsJSON()) {\r\n        return value;\r\n      }\r\n\r\n      try {\r\n        // We can't tell if its JSON or a string, so we try to parse\r\n        return JSON.parse(value);\r\n      } catch (e) {\r\n        // If we can't parse, it's probably because it isn't an object\r\n        return value;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes a value from localStorage.\r\n     * Equivalent to 'delete' in memcache, but that's a keyword in JS.\r\n     * @param {string} key\r\n     */\r\n    remove: function(key) {\r\n      if (!supportsStorage()) return;\r\n\r\n      flushItem(key);\r\n    },\r\n\r\n    /**\r\n     * Returns whether local storage is supported.\r\n     * Currently exposed for testing purposes.\r\n     * @return {boolean}\r\n     */\r\n    supported: function() {\r\n      return supportsStorage();\r\n    },\r\n\r\n    /**\r\n     * Flushes all lscache items and expiry markers without affecting rest of localStorage\r\n     */\r\n    flush: function() {\r\n      if (!supportsStorage()) return;\r\n\r\n      eachKey(function(key) {\r\n        flushItem(key);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Flushes expired lscache items and expiry markers without affecting rest of localStorage\r\n     */\r\n    flushExpired: function() {\r\n      if (!supportsStorage()) return;\r\n\r\n      eachKey(function(key) {\r\n        flushExpiredItem(key);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Appends CACHE_PREFIX so lscache will partition data in to different buckets.\r\n     * @param {string} bucket\r\n     */\r\n    setBucket: function(bucket) {\r\n      cacheBucket = bucket;\r\n    },\r\n\r\n    /**\r\n     * Resets the string being appended to CACHE_PREFIX so lscache will use the default storage behavior.\r\n     */\r\n    resetBucket: function() {\r\n      cacheBucket = '';\r\n    },\r\n\r\n    /**\r\n     * @returns {number} The currently set number of milliseconds each time unit represents in\r\n     *   the set() function's \"time\" argument.\r\n     */\r\n    getExpiryMilliseconds: function() {\r\n      return expiryMilliseconds;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of milliseconds each time unit represents in the set() function's\r\n     *   \"time\" argument.\r\n     * Sample values:\r\n     *  1: each time unit = 1 millisecond\r\n     *  1000: each time unit = 1 second\r\n     *  60000: each time unit = 1 minute (Default value)\r\n     *  360000: each time unit = 1 hour\r\n     * @param {number} milliseconds\r\n     */\r\n    setExpiryMilliseconds: function(milliseconds) {\r\n        expiryMilliseconds = milliseconds;\r\n        maxDate = calculateMaxDate(expiryMilliseconds);\r\n    },\r\n\r\n    /**\r\n     * Sets whether to display warnings when an item is removed from the cache or not.\r\n     */\r\n    enableWarnings: function(enabled) {\r\n      warnings = enabled;\r\n    }\r\n  };\r\n\r\n  // Return the module\r\n  return lscache;\r\n}));\r\n"]},"metadata":{},"sourceType":"script"}